import { Component, OnInit } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { ActivatedRoute } from '@angular/router';
import { TangyErrorHandler } from 'src/app/shared/_services/tangy-error-handler.service';
import * as XLSX from 'xlsx';
import { GroupsService } from '../services/groups.service';
import { Loc } from 'tangy-form/util/loc.js';
import { _ } from 'underscore';
type AOA = any[][];
@Component({
  selector: 'app-import-location-list',
  templateUrl: './import-location-list.component.html',
  styleUrls: ['./import-location-list.component.css']
})
export class ImportLocationListComponent implements OnInit {
  constructor(
    private http: HttpClient,
    private route: ActivatedRoute,
    private errorHandler: TangyErrorHandler,
    private groupsService: GroupsService
  ) { }
  parsedCSVData: AOA = [[1, 2], [3, 4]];
  canUserImportFile: boolean;
  locationList: any;
  groupName = '';
  locationListLevels = [];
  CSVHeaders;
  headerModel = {};
  metadataModel = {};
  mappings = {};
  locationsMetadata = {};
  autoGeneratedIDLabel = 'AutoGeneratedID';
  locationListFileName = 'location-list.json';
  generatedLocationList: any;
  async ngOnInit() {
    this.route.params.subscribe(params => {
      this.groupName = params.groupName;
    });
    this.locationList = await this.http.get(`/editor/${this.groupName}/content/location-list.json`).toPromise();
    this.locationListLevels = this.locationList.locationsLevels;
    this.canUserImportFile = this.isLocationListEmpty() && !this.isLocationHierarchiesEmpty();
  }
  isLocationListEmpty() {
    return Object.keys(this.locationList.locations).length === 0 && this.locationList.locations.constructor === Object;
  }
  isLocationHierarchiesEmpty() {
    return this.locationList.locationsLevels.length < 1;
  }

  importLocationListFile(fileInput) {
    this.CSVHeaders = [];
    this.mappings = {};
    try {
      const target: DataTransfer = <DataTransfer>(fileInput);
      if (target.files.length !== 1) {
        this.errorHandler.handleError('Please select one file only');
      }
      const reader: FileReader = new FileReader();
      reader.onload = (e: any) => {
        const binaryString: string = e.target.result;
        const workBook: XLSX.WorkBook = XLSX.read(binaryString, { type: 'binary' });
        const worksheetName: string = workBook.SheetNames[0];
        const worksheet: XLSX.WorkSheet = workBook.Sheets[worksheetName];
        this.parsedCSVData = <AOA>(XLSX.utils.sheet_to_json(worksheet));
        this.CSVHeaders = [this.autoGeneratedIDLabel, ...Object.keys(this.parsedCSVData[0]).sort()];

      };
      reader.readAsBinaryString(target.files[0]);
    } catch (error) {
      console.error(error);
      this.errorHandler.handleError('Could not Import File.');
    }

  }
  onSelectLocationLevelsMapping(locationLevel, value) {
    this.mappings[locationLevel] = value;
  }
  onSelectMetadataMapping(locationLevel, metadata, value) {
    this.locationsMetadata[locationLevel] = { ...this.locationsMetadata[locationLevel], [metadata]: value };
  }
  async processLocationListData() {
    try {
      const headers: any = this.validateColumns();
      if (!headers.isValid) {
        this.errorHandler.handleError(`empty values on line: "${headers.row}" at column "${headers.column}"`);
      }
      this.generateIDs();
      this.transformFromMappings();
      await this.saveLocationList();
    } catch (error) {

    }
  }
  validateColumns() {
    // check if any of the columns are empty
    let status = {};
    this.locationListLevels.forEach(e => {
      if (this.mappings[e] === this.autoGeneratedIDLabel) {
        return;
      } else {
        const index = this.parsedCSVData.findIndex(row => !row[this.mappings[e]]);
        if (index > 0) {
          // Add 2 to index because Javascript is 0-indexed and the CSV file contains headers on the first row.
          status = { isValid: false, row: index + 2, column: this.mappings[e] };
          return status;
        }
        status = { isValid: true };
      }
    });
    return status;
  }

  generateIDs() {
    const autoGenerateIDs = Object.values(this.mappings).findIndex(m => m === this.autoGeneratedIDLabel);
    let generatedIDs = [];
    const levels = [...this.locationList.locationsLevels].reverse();
    if (autoGenerateIDs < 0) { return; } else {
      this.parsedCSVData.map((elem, index) => {
        levels.map((level, ind) => {
          if (this.mappings[`${levels[ind]}_id`] === this.autoGeneratedIDLabel) {
            const i = generatedIDs.findIndex(e => e.label === elem[this.mappings[`${levels[ind]}`]] && e.level === level);
            if (i >= 0) {
              this.parsedCSVData[index][`${level}_id`] = generatedIDs[i][`${level}_id`];
            } else {
              const id = this.groupsService.generateID();
              this.parsedCSVData[index][this.mappings[`${levels[ind]}_id`]] = id;
              generatedIDs = [...generatedIDs, { label: elem[this.mappings[`${levels[ind]}`]], level, [`${level}_id`]: id }];
            }
          }
        });
      });
    }
  }

  transformFromMappings() {
    let locations = [];
    const levels = [...this.locationList.locationsLevels].reverse();
    levels.map((level, index) => {
      this.parsedCSVData.map(item => {
        const id = item[this.mappings[`${levels[index]}_id`]];
        const parent = index + 1 === levels.length ? 'root' : item[`${levels[index + 1]}_id`];
        let value = {
          parent,
          label: item[this.mappings[level]].toString(),
          id,
          level: this.mappings[level]
        };
        const levelMetadataKeys = this.locationsMetadata[level] ? Object.keys(this.locationsMetadata[level]) : [];
        if (levelMetadataKeys.length > 0) {
          for (const key of levelMetadataKeys) {
            const metadataKey = this.locationsMetadata[level][key];
            value = { ...value, [key]: item[metadataKey] };
          }
        }
        const itemIndex = locations.findIndex(e => e.label === value.label && e.level === value.level && e.parent === value.parent);
        if (itemIndex > 0) { return; }
        locations = [
          ...locations,
          value
        ];
      });
    });
    this.generatedLocationList = Loc.unflatten({ locations, locationsLevels: this.locationList.locationsLevels });
  }
  async saveLocationList() { }
  async saveLocationListToDisk() {
    try {
      const payload = {
        filePath: this.locationListFileName, groupId: this.groupName,
        fileContents: JSON.stringify(this.generatedLocationList)
      };
      await this.http.post(`/editor/file/save`, payload).toPromise();
      this.errorHandler.handleError(`Successfully saved Location list for Group: ${this.groupName}`);
    } catch (error) {
      this.errorHandler.handleError('Error Saving Location List File to disk');
    }
  }

}

