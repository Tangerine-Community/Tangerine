var Sanitize =
	/******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};

	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {

		/******/ 		// Check if module is in cache
		/******/ 		if(installedModules[moduleId])
		/******/ 			return installedModules[moduleId].exports;

		/******/ 		// Create a new module (and put it into the cache)
		/******/ 		var module = installedModules[moduleId] = {
			/******/ 			exports: {},
			/******/ 			id: moduleId,
			/******/ 			loaded: false
			/******/ 		};

		/******/ 		// Execute the module function
		/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

		/******/ 		// Flag the module as loaded
		/******/ 		module.loaded = true;

		/******/ 		// Return the exports of the module
		/******/ 		return module.exports;
		/******/ 	}


	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;

	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;

	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";

	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
/************************************************************************/
/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {

		/*jshint node:true*/
		'use strict';

		/**
		 * Replaces characters in strings that are illegal/unsafe for filenames.
		 * Unsafe characters are either removed or replaced by a substitute set
		 * in the optional `options` object.
		 *
		 * Illegal Characters on Various Operating Systems
		 * / ? < > \ : * | "
		 * https://kb.acronis.com/content/39790
		 *
		 * Unicode Control codes
		 * C0 0x00-0x1f & C1 (0x80-0x9f)
		 * http://en.wikipedia.org/wiki/C0_and_C1_control_codes
		 *
		 * Reserved filenames on Unix-based systems (".", "..")
		 * Reserved filenames in Windows ("CON", "PRN", "AUX", "NUL", "COM1",
		 * "COM2", "COM3", "COM4", "COM5", "COM6", "COM7", "COM8", "COM9",
		 * "LPT1", "LPT2", "LPT3", "LPT4", "LPT5", "LPT6", "LPT7", "LPT8", and
		 * "LPT9") case-insesitively and with or without filename extensions.
		 *
		 * Capped at 255 characters in length.
		 * http://unix.stackexchange.com/questions/32795/what-is-the-maximum-allowed-filename-and-folder-size-with-ecryptfs
		 *
		 * @param  {String} input   Original filename
		 * @param  {Object} options {replacement: String}
		 * @return {String}         Sanitized filename
		 */

		var truncate = __webpack_require__(1);

		var illegalRe = /[\/\?<>\\:\*\|":]/g;
		var controlRe = /[\x00-\x1f\x80-\x9f]/g;
		var reservedRe = /^\.+$/;
		var windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
		var windowsTrailingRe = /[\. ]+$/;

		function sanitize(input, replacement) {
			var sanitized = input
				.replace(illegalRe, replacement)
				.replace(controlRe, replacement)
				.replace(reservedRe, replacement)
				.replace(windowsReservedRe, replacement)
				.replace(windowsTrailingRe, replacement);
			return truncate(sanitized, 255);
		}

		module.exports = function (input, options) {
			var replacement = (options && options.replacement) || '';
			var output = sanitize(input, replacement);
			if (replacement === '') {
				return output;
			}
			return sanitize(output, '');
		};


		/***/ },
	/* 1 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		var truncate = __webpack_require__(2);
		var getLength = __webpack_require__(3);
		module.exports = truncate.bind(null, getLength);


		/***/ },
	/* 2 */
	/***/ function(module, exports) {

		'use strict';

		function isHighSurrogate(codePoint) {
			return codePoint >= 0xd800 && codePoint <= 0xdbff;
		}

		function isLowSurrogate(codePoint) {
			return codePoint >= 0xdc00 && codePoint <= 0xdfff;
		}

		// Truncate string by size in bytes
		module.exports = function truncate(getLength, string, byteLength) {
			if (typeof string !== "string") {
				throw new Error("Input must be string");
			}

			var charLength = string.length;
			var curByteLength = 0;
			var codePoint;
			var segment;

			for (var i = 0; i < charLength; i += 1) {
				codePoint = string.charCodeAt(i);
				segment = string[i];

				if (isHighSurrogate(codePoint) && isLowSurrogate(string.charCodeAt(i + 1))) {
					i += 1;
					segment += string[i];
				}

				curByteLength += getLength(segment);

				if (curByteLength === byteLength) {
					return string.slice(0, i + 1);
				}
				else if (curByteLength > byteLength) {
					return string.slice(0, i - segment.length + 1);
				}
			}

			return string;
		};



		/***/ },
	/* 3 */
	/***/ function(module, exports) {

		'use strict';

		function isHighSurrogate(codePoint) {
			return codePoint >= 0xd800 && codePoint <= 0xdbff;
		}

		function isLowSurrogate(codePoint) {
			return codePoint >= 0xdc00 && codePoint <= 0xdfff;
		}

		// Truncate string by size in bytes
		module.exports = function getByteLength(string) {
			if (typeof string !== "string") {
				throw new Error("Input must be string");
			}

			var charLength = string.length;
			var byteLength = 0;
			var codePoint = null;
			var prevCodePoint = null;
			for (var i = 0; i < charLength; i++) {
				codePoint = string.charCodeAt(i);
				// handle 4-byte non-BMP chars
				// low surrogate
				if (isLowSurrogate(codePoint)) {
					// when parsing previous hi-surrogate, 3 is added to byteLength
					if (prevCodePoint != null && isHighSurrogate(prevCodePoint)) {
						byteLength += 1;
					}
					else {
						byteLength += 3;
					}
				}
				else if (codePoint <= 0x7f ) {
					byteLength += 1;
				}
				else if (codePoint >= 0x80 && codePoint <= 0x7ff) {
					byteLength += 2;
				}
				else if (codePoint >= 0x800 && codePoint <= 0xffff) {
					byteLength += 3;
				}
				prevCodePoint = codePoint;
			}

			return byteLength;
		};


		/***/ }
	/******/ ]);