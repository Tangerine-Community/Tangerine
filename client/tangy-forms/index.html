<!doctype html>
<html lang="en">
  <head>

    <link rel="manifest" href="/manifest.json">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
    <meta name="description" content="tangy description">

    <title>Tangerine Forms</title>

    <!--<script src="js/custom-elements-es5-adapter.js"></script>-->
    <!--<script src="js/webcomponents-loader.js"></script>-->
    <!--<script src="js/polyfill.js"></script>-->
    <!--<script src="js/babel-browser-build.js"></script>-->
    <!--<script src="js/browser-es-module-loader.js"></script>-->
    <script src="js/redux.js"></script>

    <!-- 
      @TODO This should be imported by the Loc.js that depends on it but underscore doesn't play well with ES6 import 
            Issue: https://github.com/jashkenas/underscore/issues/2152
    -->
    <script src="js/underscore.js"></script>

    <link href="fonts/fonts.css" rel="stylesheet">
    <style>
      body  {
        min-height: 100vh;
        padding: 0px;
        margin: 0px;
        background: #FAFAFA;
      }
    </style>

  </head>

  <body>

    <div id="base-path-loader"></div>

    <div id="tangy-form-app-loading" style="text-align: center; margin: auto; width: 300px">
      Loading...
      <paper-progress style="margin: auto" indeterminate class="slow"></paper-progress>
    </div>

    <tangy-form-app></tangy-form-app>

    <!--
    Feature detect Custom Elements support. If the browser DOES support Custom
    Elements then we need to load the custom-elements-es5-adapter because
    our project code has been transpiled from ES2015 to ES5 and native Custom
    Elements expect elements will be registered as classes.
  -->
    <div id="ce-es5-shim">
      <script type="text/javascript">

        const supportsAsyncFunctions = (() => {
          try {
            new Function('async () => {}')();
          } catch (error) {
            return false;
          }
          return true;
        })();

        var bundleScriptName;
        if (supportsAsyncFunctions) {
          console.log("I can run async.")
          bundleScriptName = 'bundleES6.js';
        } else {
          console.log("Must use transpiled code.")
          bundleScriptName = 'bundleES5.js';
        }
        // bundleES6 does not use babel, so don't need to use the shim.
        if ((bundleScriptName === 'bundleES6.js') || (!window.customElements)) {
          console.log("Disabling the CE shim.")
          var ceShimContainer = document.querySelector('#ce-es5-shim');
          ceShimContainer.parentElement.removeChild(ceShimContainer);
        }

      </script>
      <script type="text/javascript" src="js/custom-elements-es5-adapter.js"></script>
    </div>
    <!--<div id="ce-babel-es-module-loader">-->
      <!--<script type="text/javascript">-->
        <!--// bundleES6 does not use babel, so don't need to use the browser-es-module-loader.-->
        <!--if (bundleScriptName == 'bundleES6.js') {-->
          <!--console.log("Disabling the browser-es-module-loader.js.")-->
          <!--var ceShimContainer = document.querySelector('#ce-babel-es-module-loader');-->
          <!--ceShimContainer.parentElement.removeChild(ceShimContainer);-->
        <!--}-->
      <!--</script>-->
      <!--<script type="text/javascript" src="js/babel-browser-build.js"></script>-->
      <!--<script type="text/javascript" src="js/browser-es-module-loader.js"></script>-->

    </div>
    <div id="ce-babel-polyfill">
      <script type="text/javascript">
        // bundleES6 does not use babel, so don't need to use the babel polyfill.
        if (bundleScriptName == 'bundleES6.js') {
          console.log("Disabling the babel polyfill.js.")
          var ceShimContainer = document.querySelector('#ce-babel-polyfill');
          ceShimContainer.parentElement.removeChild(ceShimContainer);
        }
      </script>
      <script type="text/javascript" src="js/polyfill.js"></script>
    </div>
    <!--
      Use the webcomponents-loader script which will feature detect which Web
      Components features are missing and lazy load the appropriate polyfills.
      When we hear the 'WebComponentsReady' event from the polyfill bundle we can
      insert our 'bundle.js'.
    -->
    <script>
      // kudos: https://stackoverflow.com/questions/43502448/how-to-detect-async-function-support-without-eval


      (function() {
        document.addEventListener('WebComponentsReady', function componentsReady() {
          document.removeEventListener('WebComponentsReady', componentsReady, false);

          // script.src = 'bundlees6.js';
          if (bundleScriptName == 'bundleES5.js') {
            // var script = document.createElement('script');
            // script.src = 'js/polyfill.js';
            // var refScript = document.getElementsByTagName('script')[0];
            // refScript.parentNode.insertBefore(script, refScript);

            // var script = document.createElement('script');
            // script.src = 'js/browser-es-module-loader.js';
            // var refScript = document.getElementsByTagName('script')[0];
            // refScript.parentNode.insertBefore(script, refScript);
            //
            // var script = document.createElement('script');
            // script.src = 'js/babel-browser-build.js';
            // var refScript = document.getElementsByTagName('script')[0];
            // refScript.parentNode.insertBefore(script, refScript);
          }

          var scriptsLength = document.getElementsByTagName('script').length
          var bundleScript = document.createElement('script');
          bundleScript.src = bundleScriptName;
          var refScript = document.getElementsByTagName('script')[scriptsLength-1];
          refScript.parentNode.insertBefore(bundleScript, refScript);
        }, false);
      })();
    </script>
    <script src="js/webcomponents-loader.js"></script>

    <!--
      IMPORTANT: Make sure you set the inject: false option in HTMLWebpackPlugin
      so it doesn't try to insert bundle.js. We're handling loading it ourselves
      up above.
    -->

  </body>
</html>
