<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<script src="../../node_modules/redux/dist/redux.js"></script>

<style>
  paper-card {
    margin: 15px 0px;
    padding: 25px;
  }
  
  label {
    display: block;
    margin-top: 15px;
    font-size: 12px;
    color: #777;
  }
</style>

<dom-module id="tangy-form-questions">

  <template>
      <style>
        :host {
          width: 100%;
          display: block;
          margin: 0px;
          padding: 0px;
        }
        #previousItemButton {
          background: #ef6433; 
          position: fixed;
          bottom: 73px;
          right: 7px;
          color: white;
        }
        #nextItemButton {
          background: #ef6433; 
          position: fixed;
          bottom: 10px;
          right: 7px;
          color: white;
        }
        :host(:not([linear-mode])) #nextItemButton,
        :host(:not([linear-mode])) #previousItemButton
         {
          display: none;
        }
        #progress {
          position: fixed;
          top: 0px;
        }
        paper-progress {
          --paper-progress-active-color: #ef6433;
          width: 100%;
        }
        paper-tab, paper-tabs {
          --paper-tabs-selection-bar-color: #ef6433 !important;
          color: #fff;
        }
      </style>
      <slot></slot>
      <div id="nav">
        <paper-fab id="previousItemButton" on-click="focusOnPreviousItem" icon="hardware:keyboard-arrow-up"></paper-fab>
        <paper-fab id="nextItemButton" on-click="focusOnNextItem" icon="hardware:keyboard-arrow-down"></paper-fab>
      </div>
      <paper-progress id="progress" value="0" secondary-progress="100"></paper-progress>
  </template>

  <script>
    /**
     * `tangy-form-questions`
     * An element used to encapsulate form elements for multipage forms with a response in PouchDB.
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */

    class TangyFormQuestions extends Polymer.Element {

      static get is() { return 'tangy-form-questions'; }

      static get properties() {
        return {
          // Pass in code to be eval'd on any form input change.
          onChange: {
            type: String,
            value: '',
            reflectToAttribute: true
          },
          // Set liniar-mode to turn on navigation and turn off item action buttons.
          linearMode: {
            type: Boolean,
            value: false,
            reflectToAttribute: true
          },
          // Hide closed items to focus user on current item.
          hideClosedItems: {
            type: Boolean,
            value: false,
            reflectToAttribute: true
          }
        };
      }

      connectedCallback() {
        super.connectedCallback()
        // Set up the store.
        this.store = window.tangyFormStore

        // Move to reducer.
        this.querySelectorAll('tangy-form-item').forEach((item) => {
          if (this.linearMode) item.noButtons = true
        })
        // Register tangy redux hook.
        window.tangyReduxHook_INPUT_VALUE_CHANGE = (store) => {
          console.log('hook override')
          let getValue = this.getValue.bind(this)
          eval(this.onChange)
          let forms = [].slice.call(this.querySelectorAll('form[on-change]'))
          forms.forEach((form) => {
            if (form.hasAttribute('on-change')) eval(form.getAttribute('on-change'))
          })
        }

        // Subscribe to the store to reflect changes.
        this.unsubscribe = this.store.subscribe(this.throttledReflect.bind(this))
 
        // Notify store is open and send up the items if it does not have them.
        if (this.response.items.length === 0) {
          this.response.items = ([].slice.call(this.querySelectorAll('tangy-form-item'))).map((element) => serializeElement(element))
        }
        formOpen(this.response)

        // Open an item if there are none open.
        let state = this.store.getState()
        let anyItemOpen = state.items.findIndex(item => item.open)
        if (anyItemOpen === -1) {
          itemOpen(state.items[0].id)
        }

        this.hasNotYetFocused = true


      }

      disconnectedCallback() {
        this.unsubscribe()
      }


      // Prevent parallel reflects, leads to race conditions.
      throttledReflect(iAmQueued = false) {
        // If there is an reflect already queued, we can quit. 
        if (this.reflectQueued && !iAmQueued) return
        if (this.reflectRunning) {
          this.reflectQueued = true
          setTimeout(() => this.throttledReflect(true), 200)
        } else {
          this.reflectRunning = true
          this.reflect()
          this.reflectRunning = false
          if (iAmQueued) this.reflectQueued = false
        }
      }

      // Apply state in the store to the DOM.
      reflect() {
        let state = this.store.getState()
        if (!this.previousState) this.previousState = state
        // Set state in tangy-form-item elements.
        let items = [].slice.call(this.querySelectorAll('tangy-form-item'))
        items.forEach((item) => {
          let index = state.items.findIndex((itemState) => item.id == itemState.id) 
          if (index !== -1) Object.assign(item, state.items[index])
        })
        // Set state in input elements.
        let inputs = [].slice.call(this.querySelectorAll('[name]'))
        inputs.forEach((input) => {
          let index = state.inputs.findIndex((inputState) => inputState.name == input.name) 
          if (index !== -1) Object.assign(input, state.inputs[index])
        })
        // Set progress state.
        this.$.progress.setAttribute('value', state.progress)
        // Hide closed items.
        if (this.hideClosedItems) {
          items.forEach((item) => {
            if (item.open) {
              item.style.display = 'block'
            } else {
              item.style.display = 'none'
            }
          })
        }
        // Find item to scroll to.
        if (state.focusIndex !== this.previousState.focusIndex || (this.linearMode && this.hasNotYetFocused)) {
          this.hasNotYetFocused = false
          setTimeout(() => {
            items[state.focusIndex].scrollIntoView({behavior: 'smooth', block: 'start'})
          }, 200)
        }  
        this.$.nextItemButton.disabled = (state.nextFocusIndex === -1) ? true : false
        this.$.previousItemButton.disabled = (state.previousFocusIndex === -1) ? true : false
        // Stash as previous state.
        this.previousState = Object.assign({}, state)
      }

      focusOnPreviousItem(event) {
        this.$.previousItemButton.setAttribute('disabled', true)
        this.$.nextItemButton.setAttribute('disabled', true)
        let items = [].slice.call(this.querySelectorAll('tangy-form-item'))
        let invalidItemIds = [] 
        items.forEach((item) => {
          if (item.validate() === false) invalidItemIds.push(item.id)
        })
        if (invalidItemIds.length > 0) {
          this.store.dispatch({ type: ITEMS_INVALID, itemIds: invalidItemIds })
        } else {
          let state = this.store.getState()
          itemOpen(state.items[state.previousFocusIndex].id)
        }
      }

      focusOnNextItem(event) {
        this.$.previousItemButton.setAttribute('disabled', true)
        this.$.nextItemButton.setAttribute('disabled', true)
        let items = [].slice.call(this.querySelectorAll('tangy-form-item'))
        let invalidItemIds = [] 
        items.forEach((item) => {
          if (item.validate() === false) invalidItemIds.push(item.id)
        })
        if (invalidItemIds.length > 0) {
          this.store.dispatch({ type: ITEMS_INVALID, itemIds: invalidItemIds })
        } else {
          let state = this.store.getState()
          this.store.dispatch({ type: ITEM_OPEN, itemId: state.items[state.nextFocusIndex].id })
        }
      }

      getValue(name) {
        let state = this.store.getState()
        let input = state.inputs.find((input) => input.name == name)
        if (input) return input.value
      }

    }

    
    window.customElements.define(TangyFormQuestions.is, TangyFormQuestions);
  </script>
</dom-module>
