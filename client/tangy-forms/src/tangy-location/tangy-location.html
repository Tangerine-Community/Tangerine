<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<script src="../../bower_components/jquery/dist/jquery.js"></script>
<script src="../../bower_components/underscore/underscore.js"></script>
<script src="./loc.js"></script>

<dom-module id="tangy-location">
  <template>
    <style>
      :host {
        display: block;
        margin-top: 15px;
      }
      :host([invalid]) {
        border: solid red 3px;
      }
      :host([required]:not([disabled])) label::before  { 
        content: "*"; 
        color: red; 
        position: absolute;
        top: 4px;
        right: 5px;
      }
      label {
        font-size: 12px;
        color: #777;
      }
    </style>
      <div id="container"></div>
      <slot></slot>
    </div>
  </template>

  <script>
    /**
     * `tangy-location`
     * 
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class TangyLocation extends Polymer.Element {
      static get is() { return 'tangy-location'; }
      static get properties() {
        return {
          name: {
            type: String,
            value: 'location'
          },
          value: {
            type: Array,
            value: [],
            // reflectToAttribute: true,
            observer: 'render'
          },
          label: {
            type: String,
            value: 'Location'
          },
          required: {
            type: Boolean,
            value: false
          },
          invalid: {
            type: Boolean,
            value: false,
            reflectToAttribute: true
          },
          locationSrc: {
            type: String,
            value: '../location-list.json'
          },
          showLevels: {
            type: String,
            value: ''
          },
          saveChildren: {
            type: Boolean,
            value: false 
          }
        };
      }

      async connectedCallback() {
        super.connectedCallback();
         
        // window.tangyFormStore.dispatch({type: 'INPUT_VALUE_CHANGE', inputName: 'location', inputValue: {}})
        this.shadowRoot.addEventListener('change', (event) => {
          let levels = this.showLevels.split(',')
          // Calculate our new value.
          let newSelections =  this.value.map(selection => {
            // Modify the selection level associated with the event.
            if (selection.level === event.target.name) {
              return {
                level: event.target.name, 
                value: event.target.value
              }
            } 
            // Make sure to set the selection values to '' for all selections after the one just selected. 
            else if (levels.indexOf(selection.level) > levels.indexOf(event.target.name)) {
              return {
                level: selection.level,
                value: ''
              }
            } 
            // Return unmodified selections if they are unrelated to this event.
            else {
              return selection
            }
          })
          this.dispatchEvent(new CustomEvent('INPUT_VALUE_CHANGE', 
            {
              detail: {
                inputName: this.name,
                inputValue: newSelections
              },
              bubbles: true
            }
          ))
        })

      }
 
      render() {

        //
        // Preprocessing.
        //

        // Selections are what is currently selected given this.value.
        let selections = []
        // Queries contain the Loc.query() parameters required to find options for a given level. Level is the key which points to an object where the properties
        // are the parameters for the Loc.query().
        let queries = {} 
        // Options is an object where the keys are the level and the value is an array of location objects that are options given previously selected.
        let options = {}
        // firstLevelNotSelected is the first level with no selection and the last level we will bother calculating options for.
        let firstLevelNotSelected = '' 
        // Levels for querying.
        let levels = this.showLevels.split(',')

        // Get selections from this.value and safeguard for not yet having a value.
        if (this.value.length === 0) {
          levels.forEach(level => {
            selections = [...selections, ...[{level, value: ''}]] 
          })
        } else {
          selections = this.value
        }

        // Find the first level not selected.
        let firstSelectionNotSelected = (selections.find(selection => (selection.value === '')))
        firstLevelNotSelected = (firstSelectionNotSelected) ? firstSelectionNotSelected.level : ''

        // Generate queries.
        selections.forEach((selection, i) => {
          // Only generate queries for levels that are selected or the first level not selected.
          if (selection.value === '' && selection.level !== firstLevelNotSelected) return 
          // Slice out the selections at this level from all selections.
          let selectionsAtThisLevel = selections.slice(0, i) 
          // Transform the array of objects to an array of levels.
          let queryLevels = selectionsAtThisLevel.map(s => s.level)
          // Transform selectionsAtThisLevel Array to queryCriteria Object.
          let queryCriteria = {} 
          selectionsAtThisLevel.forEach(selection =>  queryCriteria[selection.level] = selection.value)
          // Set the query.
          queries[selection.level] = {
            levels: queryLevels,
            criteria: queryCriteria
          }
        })

        // Run queries to get options.
        selections.forEach(selection => {
          if (queries[selection.level]) {
            let query = queries[selection.level]
            Loc.query(levels, query.criteria, (res) => {
              options[selection.level] = res
            })
          } else {
            options[selection.level] = []
          }
        })

        //
        // Render
        //

        this.$.container.innerHTML = `
          <label>${this.label}</label> <br>
          ${selections.map((selection, i) => `
            <label ${(options[selection.level].length === 0) ? 'hidden' : ''}> 
              ${selection.level} 
            </label>
            <select name=${selection.level}
              ${(options[selection.level].length === 0) ? 'hidden' : ''}
            > 
              <option
                ${(selection.value === '') ? 'selected' : ''} 
                disabled='disabled'
              >
                Select...
              </option>
              ${options[selection.level].map((option, i) => `
                <option 
                  value="${option.id}" 
                  ${(selection.value === option.id) ? 'selected' : ''}
                 >
                  ${option.label}
                </option>
              `)}
            </select><br> 
          `).join('')}
        `

      }

    }

    window.customElements.define(TangyLocation.is, TangyLocation);
  </script>
</dom-module>
