<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<script src="../../bower_components/jquery/dist/jquery.js"></script>
<script src="../../bower_components/underscore/underscore.js"></script>
<script src="./loc.js"></script>

<dom-module id="tangy-location">
  <template>
    <style>
      :host {
        display: block;
        margin-top: 15px;
      }
      :host([invalid]) {
        border: solid red 3px;
      }
      :host([required]:not([disabled])) label::before  { 
        content: "*"; 
        color: red; 
        position: absolute;
        top: 4px;
        right: 5px;
      }
      label {
        font-size: 12px;
        color: #777;
      }
    </style>
      <label>Location</label>
      <div id="loading">Loading location list...</div>
      <slot></slot>
    </div>
  </template>

  <script>
    /**
     * `tangy-location`
     * 
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class TangyLocation extends Polymer.Element {
      static get is() { return 'tangy-location'; }
      static get properties() {
        return {
          name: {
            type: String,
            value: 'location'
          },
          value: {
            type: String,
            value: '',
            reflectToAttribute: true
          },
          required: {
            type: Boolean,
            value: false
          },
          invalid: {
            type: Boolean,
            value: false,
            reflectToAttribute: true
          },
          locationSrc: {
            type: String,
            value: '../location-list.json'
          },
          showLevels: {
            type: String,
            value: ''
          },
          saveChildren: {
            type: Boolean,
            value: false 
          }
        };
      }

      // Element class can define custom element reactions
      // @TODO: Duplicating ready?
      async connectedCallback() {
        super.connectedCallback();
        this.selected = {}
        if (this.value == "") this.value = '{}'
        try {
          // this.selected = JSON.parse(`[${this.value}`)
          this.selected = JSON.parse(this.value)
        } catch(e) {
          console.log(`${this.name} was given invalid JSON`)
        }
        let response = await fetch(this.locationSrc)
        let options = await response.json()
        this.$.loading.innerHTML = ''
        window.locationList = options
        if (options == null) {
          options = {};
        }
        this.showTitles = options.showTitles != null ? options.showTitles : true;
        if (this.showLevels) {
          this.levels = this.showLevels.split(',')
        } else {
          this.levels = options.locationsLevels
        }
        this.addedOptions = options.addedOptions != null ? options.addedOptions : false;
        this.render()
      }

      onChange (event) {
        this.value = JSON.stringify(this.selection())
        var index;
        $(event.target).closest("div").nextAll().remove();
        index = parseInt($(event.target).attr('data-index'));
        if (index + 1 !== this.levels.length) {
          this.renderOne(index + 1);
        } else if (this.saveChildren) {
          this.setChildren()
        }
        if (this.invalid) this.validate()
        // @TODO This is causing PouchDB conflicts somehow?
        // return this.dispatchEvent(new Event("change", {bubbles: true}));
      }

      setChildren() {
        console.log('Setting children')
        // let selectedOptions = this.querySelectorAll('option[selected="selected"]')
        let criteria = this.selection();
        // @TODO The right place to get locationList?
        let childrenLevel = window.locationList.locationsLevels.slice(0, this.levels.length)
        Loc.query(childrenLevel, criteria, (res) => {
          // @TODO If reselect, then modify existing. We probably want to set this input on connected callback, then just update it here.
          this.insertAdjacentHTML('beforeend',"<div><input type='hidden' name='" + this.name + "-children' value='" + JSON.stringify(res) + "'></div>")
          let childrenInputEl = this.querySelector(`[name=${this.name}-children]`)
          setTimeout(() => {
            childrenInputEl.dispatchEvent(new Event('change', {bubbles: true}))
          }, 1000)
          // criteria[window.locationList.locationsLevels[this.levels.length]] = res
          // this.value = JSON.stringify(criteria) 
        })

      }

      // @TODO This does not work if the last level is not set.
      validate () {
        if (!this.required) return true
        var j, len, level, ref, value;
        value = this.selection();
        ref = this.levels;
        for (j = 0, len = ref.length; j < len; j++) {
          level = ref[j];
          if (!value[level]) {
            this.setAttribute('invalid', true)
            return false;
          }
        }
        this.removeAttribute('invalid')
        return true;
      }

      selection () {
        var i, j, len, level, ref, result;
        result = {};
        ref = this.levels;
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          level = ref[i];
          let selectEl = this.querySelector("[data-index='" + i + "']")
          if (selectEl) {
            result[level] = selectEl.options[selectEl.selectedIndex].value;
          }
        }
        return result;
      }

      renderOne (index) {
        var criteria;
        if (index === 0) {
          criteria = {};
        } else {
          criteria = this.selection();
        }
        return Loc.query(this.levels, criteria, (res) => {
          var htmlOptions, noPreSelection, selected, title;
          if (this.addedOptions) {
            res = this.addedOptions[index].concat(res);
          }
          if (typeof res === 'object' && res.length !== undefined) {
            res = res.sort(function(a, b) {
              if (a.label.toLowerCase() < b.label.toLowerCase()) {
                return -1;
              } else if (a.label.toLowerCase() > b.label.toLowerCase()) {
                return 1;
              } else {
                return 0;
              }
            });
            htmlOptions = res.map(function(el) {
              var selected;
              // Populate selected data.
              if ((this.selected[this.levels[index]] != null) && el.id === this.selected[this.levels[index]]) {
                selected = "selected='selected'";
              }
              return "<option value='" + el.id + "' " + (selected || '') + ">" + el.label + "</option>";
            }, this);
          }
          if (this.showTitles) {
            // @TODO
            // title = this.levels[index].titleize();
            title = this.levels[index];
          }
          noPreSelection = this.selected[index] == null;
          if (noPreSelection) {
            selected = "selected='selected'";
          }
          this.insertAdjacentHTML('beforeend',"<div> <label>" + (title || '') + " <select name='" + this.name + "-" + this.levels[index] + "' data-index='" + index + "'> <option " + (selected || '') + " disabled='disabled'>Select...</option> " + htmlOptions + " </select> </label> <br> </div>")
          let selectElements = this.querySelectorAll('select')
          let latestSelectElement = selectElements[selectElements.length-1]
          latestSelectElement.addEventListener('change', this.onChange.bind(this))

          
          if (this.selected.length !== 0) {
            // if (index + 1 === this.selected.length) {
            if (index + 1 === this.levels.length) {
              this.querySelectorAll('div').forEach((selectEl, i) => {
                if (i !== 0) selectEl.setAttribute('hidden', true)
              })
              return this.selected = [];
            } else {
              return this.renderOne(index + 1);
            }
          }
        }, this);
      }
      render () {
        this.renderOne(0);

      }
    
    }

    window.customElements.define(TangyLocation.is, TangyLocation);
  </script>
</dom-module>
