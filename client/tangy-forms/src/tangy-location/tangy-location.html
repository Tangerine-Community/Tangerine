<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<script src="../../bower_components/jquery/dist/jquery.js"></script>
<script src="../../bower_components/underscore/underscore.js"></script>
<script src="./loc.js"></script>

<dom-module id="tangy-location">
  <template>
    <style>
      :host {
        display: block;
        margin-top: 15px;
      }
      :host([invalid]) {
        border: solid red 3px;
      }
      :host([required]:not([disabled])) label::before  { 
        content: "*"; 
        color: red; 
        position: absolute;
        top: 4px;
        right: 5px;
      }
      label {
        font-size: 12px;
        color: #777;
      }
    </style>
      <div id="container"></div>
      <slot></slot>
    </div>
  </template>

  <script>
    /**
     * `tangy-location`
     * 
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class TangyLocation extends Polymer.Element {
      static get is() { return 'tangy-location'; }
      static get properties() {
        return {
          name: {
            type: String,
            value: 'location'
          },
          value: {
            type: Array,
            value: [],
            // reflectToAttribute: true,
            observer: 'render'
          },
          required: {
            type: Boolean,
            value: false
          },
          invalid: {
            type: Boolean,
            value: false,
            reflectToAttribute: true
          },
          locationSrc: {
            type: String,
            value: '../location-list.json'
          },
          showLevels: {
            type: String,
            value: ''
          },
          saveChildren: {
            type: Boolean,
            value: false 
          }
        };
      }

      // Element class can define custom element reactions
      // @TODO: Duplicating ready?
      async connectedCallback() {
        super.connectedCallback();
         
        // window.tangyFormStore.dispatch({type: 'INPUT_VALUE_CHANGE', inputName: 'location', inputValue: {}})
        /*
        this.shadowDom.addEventListener('change', (event) => this.dispatchEvent('INPUT_VALUE_CHANGE', {
          details: {
            inputName: this.name,
            inputValue: {...this.value, { $event.target.name: event.target.value }}
          }
        }))
        */
      }
 
      render() {

        //
        // Preprocessing.
        //

        // Selections are what is currently selected given this.value.
        let selections = []
        // Queries contain the Loc.query() parameters required to find options for a given level. Level is the key which points to an object where the properties
        // are the parameters for the Loc.query().
        let queries = {} 
        // Options is an object where the keys are the level and the value is an array of location objects that are options given previously selected.
        let options = {}
        // firstLevelNotSelected is the first level with no selection and the last level we will bother calculating options for.
        let firstLevelNotSelected = '' 
        // Levels for querying.
        let levels = this.showLevels.split(',')

        // Get selections from this.value and safeguard for not yet having a value.
        if (this.value.length === 0) {
          levels.forEach(level => {
            selections = [...selections, ...[{level, value: ''}]] 
          })
        } else {
          selections = this.value
        }

        // Find the first level not selected.
        firstLevelNotSelected = (selections.find(selection => (selection.value === ''))).level

        // Generate queries.
        selections.forEach((selection, i) => {
          // Only generate queries for levels that are selected or the first level not selected.
          if (selection.value === '' && selection.level !== firstLevelNotSelected) return 
          // Slice out the selections at this level from all selections.
          let selectionsAtThisLevel = selections.slice(0, i) 
          // Transform the array of objects to an array of levels.
          let queryLevels = selectionsAtThisLevel.map(s => s.level)
          // Transform selectionsAtThisLevel Array to queryCriteria Object.
          let queryCriteria = {} 
          selectionsAtThisLevel.forEach(selection =>  queryCriteria[selection.level] = selection.value)
          // Set the query.
          queries[selection.level] = {
            levels: queryLevels,
            criteria: queryCriteria
          }
        })

        // Run queries to get options.
        selections.forEach(selection => {
          if (queries[selection.level]) {
            let query = queries[selection.level]
            Loc.query(levels, query.criteria, (res) => {
              options[selection.level] = res
            })
          } else {
            options[selection.level] = []
          }
        })

        //
        // Render
        //

        this.$.container.innerHTML = `
          <label>Location</label>
          ${selections.map((selection, i) => `
            <label> ${selection.level} </label>
            <select name=${selection.level}> 
              <option
                ${(selection.value === '') ? 'selected' : ''} 
                disabled='disabled'
              >
                Select...
              </option>
              ${options[selection.level].map((option, i) => `
                <option 
                  value="${option.id}" 
                  ${(selection.value === option.id) ? 'selected' : ''}
                 >
                  ${option.label}
                </option>
              `)}
            </select> 
          `).join('')}
        `

        // @TODO In reducer, if a level was just selected that is somewhere in the middle of selection, unset everything after it.
      }

      /*

      onChange (event) {

        // this.calculateTreeFromShadowDOM()

        // If we have an level that is not selected, render again.
        if (this.levels.find(level => this.selected[level] === '' )) {
          this.render();
        } else {
          this.done()
        }
      } 

      calculateTreeFromLightDOM() {
        // Get selected.
        let inputs = this.querySelectorAll('[name]')
        inputs.forEach((input, i) => {
          if (input.name === `${this.name}-children`) return
          this.selected[this.levels[i]] = input.value
        })

        return Loc.query(this.levels, this.state, (res) => {
        })
      }

      calculateTreeFromShadowDOM() {
        // Get selected.
        let inputs = this.querySelectorAll('[name]')
        inputs.forEach((input, i) => {
          if (input.name === `${this.name}-children`) return
          this.selected[this.levels[i]] = input.value
        })

        return Loc.query(this.levels, this.state, (res) => {
        })
      }
      */

    }

    window.customElements.define(TangyLocation.is, TangyLocation);
  </script>
</dom-module>
